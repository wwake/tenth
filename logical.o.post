// Global register values
// Free: x23, x28
// Return codes for readWord
.equ WORD_FOUND, 0
.equ STRING_FOUND, 1
.equ NUMBER_FOUND, 2

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm
.macro ROUND_UP_8 register
 add \register, \register, #8
 and \register, \register, #-8
.endm

.global andRoutine
.global orRoutine
.global xorRoutine
.global notRoutine
.global bangRoutine
.text
.align 2
// and - replace top two a,b with b&a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has two values replaced by logical and
andRoutine:
 DATA_POP_AB x1, x0
 and x0, x0, x1
 DATA_PUSH x0
 ret
// or - replace top two a,b with b|a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has two values replaced by logical or
orRoutine:
 DATA_POP_AB x1, x0
 orr x0, x0, x1
 DATA_PUSH x0
 ret
// xor - replace top two a,b with b^a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has two values replaced by logical xor
xorRoutine:
 DATA_POP_AB x1, x0
 eor x0, x0, x1
 DATA_PUSH x0
 ret
// not - replace top value with ~a
// Input: Data stack with one value on top
// Process: x0 - temp
// Output: Data stack has one values replaced by logical not
notRoutine:
 DATA_POP x0
 mvn x0, x0
 DATA_PUSH x0
 ret
// bang - replace top value with !a  (0=>1, non-zero=>0)
// Input: Data stack with one value on top
// Process: x0 - temp
// Output: Data stack has value a replaced by !a
bangRoutine:
 DATA_POP x0
 CMP x0, #0
 cset x0, eq
 DATA_PUSH x0
 ret
