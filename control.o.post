// Global register values
// Free: x23, x28
// Return codes for readWord
.equ WORD_FOUND, 0
.equ STRING_FOUND, 1
.equ NUMBER_FOUND, 2

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm
.macro ROUND_UP_8 register
 add \register, \register, #8
 and \register, \register, #-8
.endm

.global init_control_stack
.global jump_if_false_word_address
.global jump_if_false
.global jump_word_address
.global jump
.global repeat
.global until
.global if
.global else
.global fi
.global while
.global do
.global od
.data
.p2align 3
control_stack: .fill 20, 8, 0
jump_if_false_word_address:
 .quad jump_if_false
jump_word_address:
 .quad jump
.text
.p2align 3
// init_control_stack
// Result: CONTROL_STACK now points to control_stack
//
init_control_stack:
 LOAD_ADDRESS x27, control_stack
 ret
// jump_if_false: evaluate top of stack, branch to specified address if false
// Input:
//   data value on top of stack
//   VPC (register) points to address value (in secondary) following jump_if_false word
// Process:
//   x0 - temp
// Output:
//   Original data value is popped
//   VPC (register), updated to either move past address value or jump to where it says
//
jump_if_false:
 DATA_POP x0
 cmp x0, #0
 b.eq L_skip_if
  add x20, x20, #8 // skip past the address
 b L_end_jump_if_false
L_skip_if:
  ldr x20, [x20] // transfer to the address
L_end_jump_if_false:
 ret
// jump: jump to target value
// Input:
//   x20 points to address value (word in secondary)
// Output:
//   x20 changed to address value it formerly pointed to (=> a jump)
//
jump:
 ldr x20, [x20]
 ret
// repeat: meta word that is the start of repeat-until loop
// Result: Store current secondary address in the control stack
//
repeat:
 CONTROL_PUSH x25
 ret
// until: meta word
//
until:
 // Write jump_if_false to secondary
 LOAD_ADDRESS x0, jump_if_false_word_address
 STORE_SEC x0
 // Pop control stack and write that 
 //    address to secondary
 CONTROL_POP x0
 STORE_SEC x0
 ret
// if - handles beginning of if statement
// Generate jump_if_false, store addr on control stack
if:
 // Generate jump_if_false
 LOAD_ADDRESS x0, jump_if_false_word_address
 STORE_SEC x0
 // Save addr to backpatch
 CONTROL_PUSH x25
 // Generate -1 as a placeholder
 mov x0, #-1
 STORE_SEC x0
 ret
// else - handles else clause
//
else:
 // Generate the jump
 LOAD_ADDRESS x0, jump_word_address
 STORE_SEC x0
 // Get the patch location
 CONTROL_POP x0
 // Push the current secondary address 
 //   to the control stack
 CONTROL_PUSH x25
 // Generate placeholder address
 mov x1, #-1
 STORE_SEC x1
 // Store addr. of else body to patch loc
 str x25, [x0]
 ret
// fi - handles end of if statement
// Pop address from control stack, 
//   backpatch current SEC_SPACE there
fi:
 CONTROL_POP x0
 str x25, [x0]
 ret
// while - handles start of while-do-od
// Push current address to control stack
//
while:
 CONTROL_PUSH x25
 ret
// do - handles middle of while-do-od
//
do:
 // Generate the jump
 LOAD_ADDRESS x0, jump_if_false_word_address
 STORE_SEC x0
 // Get the placeholder address to patch
 CONTROL_PUSH x25
 // Generate placeholder address
 mov x1, #-1
 STORE_SEC x1
 ret
// od - handles end of while-do-od
od:
 // Generate the jump
 LOAD_ADDRESS x0, jump_word_address
 STORE_SEC x0
 // Pop jump_if_false (x0) and 
 //   start address (x1)
 CONTROL_POP x0
 CONTROL_POP x1
 // Write start address for jump
 STORE_SEC x1
 // Patch jump_if_false address
 str x25, [x0]
 ret
