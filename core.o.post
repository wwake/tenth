// Global register values
// Free: x23, x27, x28

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm

.include "repl.macros"
.global data_stack
.global data_stack_init
.global nl
.global _colon
.global _semicolon
.global _push_word_address
.global _push
.global push1
.global dup
.global add
.global sub
.global mul
.global neq
.global _jump
.global _jump_if_false
.equ DATA_STACK_SIZE, 10000
.data
.align 2
.quad 0 // empty space in front of stack
// data_stack: Run-time data stack, pointed to by X19 (VSP)
// VSP points to the next place to write
data_stack:
 .fill DATA_STACK_SIZE, 8, 0
// --------------------------
.text
.align 2
// data_stack_init - setup stack and VSP
//
data_stack_init:
 LOAD_ADDRESS x19, data_stack
 ret
// nl - print a newline
// Input: none
// Process:
//   x0 - used as temp to refer to NL character
// Output:
//   value is printed
nl:
 STD_PROLOG
 adr x0, L_nl_character
 bl print
 STD_EPILOG
 ret
L_nl_character:
 .asciz "\n"
L_colon:
 .asciz "in :\n"
L_semicolon:
 .asciz "in ;\n"
.p2align 2
// _colon (:) - enter compile mode
_colon:
 STD_PROLOG
 // Read the word to be defined
 bl readWord
 // Put word string after last secondary
 mov x1, x25
 bl strcpyz
 // Adjust SEC_SPACE to a 64-bit boundary
 mov x0, x25
 bl strlen
 add x0, x0, #8
 and x0, x0, #-8
 mov x1, x25
 add x25, x25, x0
 // Put old dictionary at first slot; update dictionary
 str x21, [x25]
 mov x21, x25
 // Put pointer to word string in 2d slot
 str x1, [x21, #8]
 // Put pointer to start2d in the third slot
 LOAD_ADDRESS x0, start2d
 str x0, [x21, #16]
 // Move SEC_SPACE past the headers
 add x25, x25, #24
 // Change to Compile mode
 mov x24, COMPILE_MODE
 STD_EPILOG
 ret
// _semicolon (;) - exit compile mode
// Write a pointer to end2d's word address as last entry in secondary
//
_semicolon:
 STD_PROLOG
 LOAD_ADDRESS x0, end2d_wordAddress
 str x0, [x25], #8
 mov x24, RUN_MODE
 STD_EPILOG
 ret
// _push - push the following word on the stack
// Input: x20 - VPC pointing to data vaue (in secondary)
// Process:
// Output:
//   VSP (register), updated as value was pushed
//   VPC (register), updated to word after data value
//
.data
.p2align 3
_push_word_address:
 .quad _push
.text
.align 2
_push:
 ldr x0, [x20], #8
 DATA_PUSH x0
 ret
push1:
 mov x0, #1
 DATA_PUSH x0
 ret
// dup - duplicate the item on top of the data stack
// Input: x19, VSP points to top of stack
// Output:
//   stack has top element duplicated
//   x19 increased
//
dup:
 DATA_TOP x0
 DATA_PUSH x0
 ret
// add - replace top two a,b with b+a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has two values replaced by sum
add:
 DATA_POP_AB x1, x0
 add x0, x0, x1
 DATA_PUSH x0
 ret
// sub - replace top a,b with b-a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has popped two values and pushed their difference
sub:
 DATA_POP_AB x1, x0
 sub x0, x0, x1
 DATA_PUSH x0
ret
// mul - replace top a,b with b*a
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has popped two values and pushed their product
mul:
 DATA_POP_AB x1, x0
 mul x0, x0, x1
 DATA_PUSH x0
 ret
// neq - pop a, b and push replace top a,b with boolean
// Input: Data stack with two values on top
// Process: x0, x1 - temp
// Output: Data stack has popped two values and pushed 1 if equal else 0
neq:
 DATA_POP_AB x1, x0
 cmp x0, x1
 cset x0, ne
 DATA_PUSH x0
ret
// _jump_if_false: evaluate top of stack, branch around code if false
// Input:
//   data value on top of stack
//   x20 points to address value (in secondary) following _jump_if_false word
// Process:
//   x0 - temp
// Output:
//   Original data value is popped
//   x20 - VPC, updated to either move past address value or jump to where it says
//
_jump_if_false:
 DATA_POP x0
 CMP x0, #0
 b.eq L_skip_if
  add x20, x20, #8 // skip past the address
 b L_end_jump_if_false
L_skip_if:
  ldr x20, [x20] // transfer to the address
L_end_jump_if_false:
 ret
// _jump: jump to target value
// Input:
//   x20 points to address value (word in secondary)
// Output:
//   x20 changed to address value it formerly pointed to (=> a jump)
//
_jump:
 ldr x20, [x20]
 ret
