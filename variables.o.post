// Global register values
// Free: x23, x28
// Return codes for readWord
.equ WORD_FOUND, 0
.equ STRING_FOUND, 1
.equ NUMBER_FOUND, 2

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm
.macro ROUND_UP_8 register
 add \register, \register, #8
 and \register, \register, #-8
.endm

.include "unix_functions.macros"
.global loadAddress
.global variable
.global at
.global assign
.global array
.global array_at
.global array_assign
.text
.align 2
// loadAddress - given address of secondary, push the following address
// Input: x0 = address of secondary
//
loadAddress:
 add x0, x0, #8
 DATA_PUSH x0
 ret
// Variable - meta word that takes the following name and makes a
//   passive word for it.
//
variable:
 STD_PROLOG
 bl readWord
 bl define_word
 LOAD_ADDRESS x0, loadAddress
 STORE_SEC x0
 STORE_SEC xzr
 STD_EPILOG
 ret
// At - pop address of variable, push its contents
//
at:
 DATA_POP x0
 ldr x0, [x0]
 DATA_PUSH x0
 ret
// Assign - pop value, then pop address of variable, store value at variable
//
assign:
 DATA_POP x1
 DATA_POP x2
 str x1, [x2]
 ret
// Array - pop value, use that as number of cells to create. a array name - creates header for name as a variable
//
array:
 STD_PROLOG
 bl variable // make header
 DATA_POP x0 // number of cells
 // write n-1 zeroes to secondary
array_loop:
  sub x0, x0, #1
  cmp x0, #0
  b.eq array_after
  STORE_SEC xzr
 b array_loop
array_after:
 STD_EPILOG
 ret
// array_at - pop index and address, push mem[address + 8 * index]
//
array_at:
 DATA_POP x1 // index
 DATA_POP x2 // variable address
 ldr x0, [x2, x1, lsl #3]
 DATA_PUSH x0
 ret
// array_assign - pop value, index, and address; store mem[address + 8 * index] = value
//
array_assign:
 DATA_POP x1 // value
 DATA_POP x2 // index
 DATA_POP x3 // address
 str x1, [x3, x2, lsl #3]
 ret
