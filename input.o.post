// Global register values
// Free: x23, x28

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm
.macro ROUND_UP_8 register
 add \register, \register, #8
 and \register, \register, #-8
.endm

.include "unix_functions.macros"
.include "repl.macros"
.global inputInit
.global readWord
.global readLine
.global inputBuffer
.equ INPUT_BUFFER_SIZE, 250
.data
L_compile_prompt:
 .asciz "\033[31mⒸ 10>\033[0m "
L_run_prompt:
 .asciz "\033[32mⓇ 10>\033[0m "
.align 2
inputBuffer:
   .fill 250, 8, 0
   .byte 0
.text
.align 2
inputInit:
 LOAD_ADDRESS x22, inputBuffer
 strb wzr, [x22]
 ret
// readLine - print prompt and read next line
// Input: none
// Uses x0, x1, x2 - temp
// Output: x0 - number of characters read
//
readLine:
 STD_PROLOG
 // prompt (with © first if in compile mode)
 and x1, x24, COMPILE_MODE
 cmp x1, COMPILE_MODE
 b.ne L_print_prompt
  LOAD_ADDRESS x0, L_compile_prompt
  bl print
  b L_reading
L_print_prompt:
 LOAD_ADDRESS x0, L_run_prompt
 bl print
 // Read a new line
L_reading:
 mov x0, #0
 LOAD_ADDRESS x1, inputBuffer
 mov x2, INPUT_BUFFER_SIZE
 unix_read #0, L_input_buffer, INPUT_BUFFER_SIZE
 STD_EPILOG
 ret
// readWord - get next word, reading new lines if necessary
// Inputs:
//   READ_LINE_ROUTINE (register) - address of the routine to call to read a line
// Output:
//   x0 - ptr to start of returned word (0-terminated string)
//   x1 - 0 for word, 1 for a string, 2 for a number
//   NEXT_WORD (register) - updated NEXT_WORD
//
readWord:
 STD_PROLOG
 // Check for NEXT_WORD at \0
L_check_if_at_end:
 ldrb w0, [x22]
 cmp w0, #0
 b.ne L_find_word_start
  blr x26
  LOAD_ADDRESS x22, inputBuffer
L_find_word_start:
 ldrb w0, [x22]
 cmp w0, #0x20 // space (skip)
 b.eq L_move_forward
 cmp w0, #0x09 // tab (skip)
 b.eq L_move_forward
 b L_look_for_string
L_move_forward:
  add x22, x22, #1
  b L_find_word_start
L_look_for_string:
  cmp w0, #34 // double quote
  b.ne L_word_start
   bl read_string
   b L_exit_word
L_word_start:
   // Look for a regular word or number
  mov x0, x22 // Set the return to point to this word
  mov x1, WORD_FOUND
  ldrb w2, [x22]
  cmp w2, 0x0a // newline
  b.ne find_trailing_space_or_nl // At end of line - go back & read more
  add x22, x22, #1
  b L_check_if_at_end
find_trailing_space_or_nl:
  ldrb w2, [x22], #1
  cmp w2, 0x0a // newline
  b.eq L_exit_word
  cmp w2, 0x20 // space
  b.eq L_exit_word
  b find_trailing_space_or_nl
L_exit_word:
 strb wzr, [x22, #-1]
 STD_EPILOG
 ret
// read_string - look for contents of quoted string
// Output:
//   x0 = pointer to unterminated string
//   x1 = STRING_FOUND code
//   NEXTWORD - points one past terminating character
//
read_string:
 // Skip past the first quote
 add x22, x22, #1
 mov x0, x22 // Set the return to point to this word
 mov x1, STRING_FOUND
L_loop_string:
  ldrb w2, [x22], #1
//		cmp w2, 0x0a		// newline
//		b.eq L_exit_string
  cmp w2, #34 // double quote
  b.eq L_exit_string
  b L_loop_string
L_exit_string:
 ret
