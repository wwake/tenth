// Global register values
// Free: x23, x28

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm

.include "unix_functions.macros"
.include "repl.macros"
.global inputInit
.global readWord
.global readLine
.global inputBuffer
.equ INPUT_BUFFER_SIZE, 250
.data
L_compile_prompt:
 .asciz "\033[31mⒸ 10>\033[0m "
L_run_prompt:
 .asciz "\033[32mⓇ 10>\033[0m "
.align 2
inputBuffer:
   .fill 250, 8, 0
   .byte 0
.text
.align 2
inputInit:
 LOAD_ADDRESS x22, inputBuffer
 strb wzr, [x22]
 ret
// readLine - print prompt and read next line
// Input: none
// Uses x0, x1, x2 - temp
// Output: x0 - number of characters read
//
readLine:
 STD_PROLOG
 // prompt (with © first if in compile mode)
 and x1, x24, COMPILE_MODE
 cmp x1, COMPILE_MODE
 b.ne L_print_prompt
  LOAD_ADDRESS x0, L_compile_prompt
  bl print
  b L_reading
L_print_prompt:
 LOAD_ADDRESS x0, L_run_prompt
 bl print
 // Read a new line
L_reading:
 mov x0, #0
 LOAD_ADDRESS x1, inputBuffer
 mov x2, INPUT_BUFFER_SIZE
 unix_read #0, L_input_buffer, INPUT_BUFFER_SIZE
 STD_EPILOG
 ret
// readWord - get next word, reading new lines if necessary
// Inputs:
//   READ_LINE_ROUTINE (register) - address of the routine to call to read a line
// Output:
//   x0 - ptr to start of returned word (0-terminated string)
//   NEXT_WORD (register) - updated NEXT_WORD
//
readWord:
 STD_PROLOG
 // Check for NEXT_WORD at \0
L_check_if_at_end:
 ldrb w0, [x22]
 cmp w0, #0
 b.ne L_find_word_start
  blr x26
  LOAD_ADDRESS x22, inputBuffer
L_find_word_start:
  ldrb w0, [x22]
  cmp w0, #0x20 // space (skip)
  b.ne not_a_space
   add x22, x22, #1
   b L_find_word_start
not_a_space:
  mov x0, x22 // Set the return to point to this word
  ldrb w1, [x22]
  cmp w1, 0x0a
  b.ne find_trailing_space_or_nl // At end of line - go back & read more
  add x22, x22, #1
  b L_check_if_at_end
find_trailing_space_or_nl:
  ldrb w1, [x22], #1
  cmp w1, 0x0a // newline
  b.eq exit_space_or_nl
  cmp w1, 0x20 // space
  b.eq exit_space_or_nl
  b find_trailing_space_or_nl
exit_space_or_nl:
 strb wzr, [x22, #-1]
 STD_EPILOG
 ret
