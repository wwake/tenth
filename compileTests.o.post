// Global register values
// Free: x23, x28

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm

.include "unix_functions.macros"
.include "asUnit.macros"
.include "coreTests.macros"
.include "repl.macros"
.global _start
.p2align 2
_start:
 STD_PROLOG
 TEST_ALL "compileTests"
 // Definition
 bl colon_switches_to_compile_mode
 bl colon_writes_header_to_secondary
 bl semicolon_switches_to_run_mode
 bl semicolon_writes_end2d_in_secondary
 unix_exit
 STD_EPILOG
 ret
TEST_START colon_switches_to_compile_mode
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 LOAD_ADDRESS x26, L_readWords
 mov x24, RUN_MODE
 // Act:
 bl _colon
 // Assert:
 mov x0, x24
 mov x1, COMPILE_MODE
 bl assertEqual
TEST_END
.data
.p2align 3
L_test_secondary_area:
 .fill 16, 8, 0
.p2align 3
L_colon_test_string:
 .asciz "xy34567 "
L_colon_test_string_final:
 .asciz "xy34567"
.text
.align 2
// L_readWords - read words for test
// Input: x0=#0, x1=addr of buffer, x2=#chars max to read
//
L_readWords:
 STD_PROLOG
 // Copy test string to real inputBuffer
 LOAD_ADDRESS x0, L_colon_test_string
 LOAD_ADDRESS x1, inputBuffer
 bl strcpyz
 STD_EPILOG
 ret
TEST_START colon_writes_header_to_secondary
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 LOAD_ADDRESS x26, L_readWords
 mov x21, #800 // starting dictionary
 // Act:
 bl _colon
 // Assert: String was written to dictionary
 LOAD_ADDRESS x0, L_test_secondary_area
 LOAD_ADDRESS x1, L_colon_test_string_final
 bl assertEqualStrings
 // Assert: SEC_SPACE was adjusted to the right boundary
 // That's 8 bytes for the string, 3*8 bytes for the header cells
 mov x0, x25
 LOAD_ADDRESS x1, L_test_secondary_area
 add x1, x1, #32
 bl assertEqual
 // Assert: First cell is pointer to old dictionary
 LOAD_ADDRESS x0, L_test_secondary_area
 add x0, x0, #8
 ldr x0, [x0]
 mov x1, #800 // starting dictionary
 bl assertEqual
 // Assert: Dictionary pointer should be updated
 mov x0, x21
 LOAD_ADDRESS x1, L_test_secondary_area
 add x1, x1, #8
 bl assertEqual
 // Assert: Second cell is pointer to new string
 ldr x0, [x21, #8]
 LOAD_ADDRESS x1, L_test_secondary_area
 bl assertEqual
 // Assert: Third cell points to start2d
 ldr x0, [x21, #16]
 LOAD_ADDRESS x1, start2d
 bl assertEqual
TEST_END
TEST_START semicolon_switches_to_run_mode
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 mov x24, COMPILE_MODE
 // Act:
 bl _semicolon
 // Assert:
 mov x0, x24
 mov x1, RUN_MODE
 bl assertEqual
TEST_END
.text
.align 2
TEST_START semicolon_writes_end2d_in_secondary
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 // Act:
 bl _semicolon
 // Assert:
 // Check that cell gets end2d's word address
 LOAD_ADDRESS x0, L_test_secondary_area
 ldr x0, [x0]
 ldr x0, [x0]
 LOAD_ADDRESS x1, end2d_wordAddress
 ldr x1, [x1]
 bl assertEqual
 // Check that SEC_SPACE moved forward after writing
 mov x0, x25
 LOAD_ADDRESS x1, L_test_secondary_area
 add x1, x1, #8
 bl assertEqual
TEST_END
