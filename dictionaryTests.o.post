// Global register values
// Free: x23, x28
.equ META, 1
.equ REGULAR, 0
// DICT_HEADER name, codeAddress
// Input:
//   name of the entry "in quotes"
//   codeAddress of code in entry
//   x21 [SYS_DICT = dictionary pointer] points to newest dictionary entry
// Process:
//   Store 3 words in next entry: link to previous dictionary entry, pointer to name string, and pointer to code
//   Increment SYS_DICT by 3 words
// Uses:
//   x0-x4 as a temp
//   SYS_DICT is increased for new entry
//
.macro DICT_HEADER name, codeAddress, isMeta=REGULAR
 str x21, [x21, #24]
 add x21, x21, #24
 LOAD_ADDRESS x0, L_DICT_HEADER_\@
 str x0, [x21, #8]
 mov x3, \isMeta
 mov x4, META
 cmp x3, x4
 b.ne L_skip_meta\@
  LOAD_ADDRESS x1, metaNext
  ldr x2, [x1]
  str x0, [x2]
  add x2, x2, #8
  str x2, [x1]
L_skip_meta\@:
 LOAD_ADDRESS x0, \codeAddress
 str x0, [x21, #16]
 .data
 L_DICT_HEADER_\@: .asciz "\name"
 .text
.endm
.macro DICT_END
 LOAD_ADDRESS x0, metaNext
 ldr x0, [x0]
 str xzr, [x0]
.endm

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm

.include "unix_functions.macros"
.include "asUnit.macros"
.global _start
.text
.p2align 2
_start:
 STD_PROLOG
 TEST_ALL "dictionaryTests"
 bl empty_dictionary_has_zeros
 bl adding_to_dictionary_adds_item
 bl adding_meta_to_dictionary
 bl isMeta_finds_only_metas
 bl search_empty_dictionary
 bl search_word_found_returns_word_address
 bl search_word_not_found_returns_0
 unix_exit
 STD_EPILOG
ret
TEST_START empty_dictionary_has_zeros
 // Act:
 bl dict_init
 // Assert:
 mov x0, x21
 LOAD_ADDRESS x1, systemDictionary
 bl assertEqual
 ldr x0, [x21]
 mov x1, #0
 bl assertEqual
TEST_END
.data
.p2align 3
L_nl_string: .asciz "nl"
L_colon_string: .asciz ":"
L_semicolon_string: .asciz ";"
L_notmeta_string: .asciz "dup"
.text
TEST_START adding_to_dictionary_adds_item
 // Arrange:
 bl dict_init
 // Act:
 DICT_HEADER "nl", nl
 DICT_END
 // Assert:
 mov x0, x21
 LOAD_ADDRESS x1, systemDictionary
 add x1, x1, #24
 bl assertEqual
 ldr x0, [x21]
 LOAD_ADDRESS x1, systemDictionary
 bl assertEqual
 ldr x0, [x21, #8]
 LOAD_ADDRESS x1, L_nl_string
 bl streq
 mov x1, #1
 bl assertEqual
 ldr x0, [x21, #16]
 LOAD_ADDRESS x1, nl
 bl assertEqual
TEST_END
TEST_START adding_meta_to_dictionary
 // Arrange:
 bl dict_init
 // Act:
 DICT_HEADER ":", colon, META
 DICT_END
 // Assert:
 LOAD_ADDRESS x0, metaList
 ldr x0, [x0]
 LOAD_ADDRESS x1, L_colon_string
 bl assertEqualStrings
 LOAD_ADDRESS x0, metaNext
 ldr x0, [x0]
 LOAD_ADDRESS x1, metaList
 add x1, x1, #8
 bl assertEqual
 LOAD_ADDRESS x0, metaNext
 ldr x0, [x0]
 ldr x0, [x0]
 mov x1, #0
 bl assertEqual
TEST_END
TEST_START isMeta_finds_only_metas
 bl dict_init
 DICT_HEADER ":", colon, META
 DICT_HEADER ";", semicolon, META
 DICT_END
 LOAD_ADDRESS x0, L_colon_string
 bl isMeta
 bl assertTrue
 LOAD_ADDRESS x0, L_semicolon_string
 bl isMeta
 bl assertTrue
 LOAD_ADDRESS x0, L_notmeta_string
 bl isMeta
 bl assertFalse
TEST_END
TEST_START search_empty_dictionary
 // Arrange:
 bl dict_init
 // Act:
 LOAD_ADDRESS x0, L_nl_string
 bl dict_search
 // Assert:
 mov x1, #0
 bl assertEqual
TEST_END
TEST_START search_word_not_found_returns_0
 // Arrange:
 bl dict_init
 DICT_HEADER "add", add
 DICT_HEADER "sub", sub
 DICT_END
 // Act:
 LOAD_ADDRESS x0, L_nl_string
 bl dict_search
 // Assert:
 mov x1, #0
 bl assertEqual
TEST_END
TEST_START search_word_found_returns_word_address
 // Arrange:
 bl dict_init
 DICT_HEADER "add", add
 DICT_HEADER "nl", nl
 DICT_HEADER "sub", sub
 DICT_END
 // Act:
 LOAD_ADDRESS x0, L_nl_string
 bl dict_search
 // Assert:
 add x1, x21, #-8
 bl assertEqual
TEST_END
