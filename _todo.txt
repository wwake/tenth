* Compile-time string constant - note we overwrite x1 from readWord
* Operators: split$, join$, make$, @+$ (?)
* How to put " in strings?  Try c's \"
* What if strings don't end by end of line?
* Try arrays of strings?
Strings

* Explore whether we can use relocatable addresses elsewhere [seems ok in data segment]
Compiler

* Read by character from terminal
* Read from a file
Input

* Check for data stack underflow
* Debugging tools for Tenth users?
Environment

Ideas
* Fill command for arrays - push n values, then n, then a, write to a[0..n-1]
* Detect stack underflow and overflow (data, control)
* Warn if you use control statements in run mode?
* Debugging - print stack before each step in start2d; dump secondary contents;


TEN-24-34: 2024-04-03 - Strings
* Run-time string constant for well-formed strings
* Operators: .$ (print)

TEN-24-33: 2024-04-02 - Variables and Arrays
Variables
* Created loadAddress that loads address of variable
* Rename _colon into colon and _semicolon to semicolon (no underscore)
* variable name [define variable]
* Operator: @, @=

Arrays
* size array name [define array with size from data stack]
* Operators: @+, @+=

TEN-24-32: 2024-04-01 - Stack Operations, if, and while
* [offline] Renamed _push* to push*, _jump* to jump*
* Check CAB - seems off - repl called pop instead of cab
* Stack operations: CAB, CBA, BAB
* Control: if-else-fi, while-do-od

TEN-24-31: 2024-03-28 - Nested Repeat-Until
* Verify nested control structures work (lang level, unit test, lldb)
Operators
  * Relational: ==, !=, <, <=, >, >=, <0, ==0
  * Stack: pop, swap

TEN-24-30: 2024-03-27 - Repeat-Until
Control
  * repeat, until
Operator
  * ! (not)
I/O
  * Change . to non-destructive print

TEN-24-29: 2024-03-26 - Operators
Operators
  * Arithmetic: MIN, MAX, /%, ABS, NEG
  * Logical: &, |, ^, ~
Control
  * Discussed several control structures
  * Wrote test for repeat-until

TEN-24-28: 2024-03-25 - Compile Numbers to “push n”
Compiler
  * Numeric constants (compile)
  * Add a word for 0
  * Define and us WORD_NOT_FOUND macro
  * Print error message in red
I/O
  * Make . pop and print a number
  * Remove automatic print from repl
Arithmetic
  * /, %

TEN_24-27: 2024-03-21 - Compiler Loose Ends
* [offline] Raised data stack size to 10K
* [offline] Decided to ignore overflow and not worry about most negative number
* [offline] Rearranged registers
* [offline] Created asUnit.key to describe asUnit
* dict_search - use x28 rather than x22 as a temp
* Should we lookup words in evalAll rather than eval and compile? No, they're too similar.
* Lookup words before REPL tests for isMeta, so we can simplify isMeta to compare pointers directly? No, it's an optimization we'll defer.
* Eliminate COMPILER_ROUTINE register
* Make readword prompt print red with Ⓒ when in compile mode - and green with Ⓡ compile mode
* Numeric constants (eval)

TEN-24-26: 2024-03-20 - REPL with NOP
Compiler/REPL
  * Fix REPL read problem (examine readLine) - readLine wrongly omitted procedure prolog/epilog
  * Write body for secondaries
  * Develop ": wordToDefine body ;"
  * Compile should report undefined words
  * Define STD_PROLOG and STD_EPILOG macros
Woohoo! You can define and run secondaries!

TEN-24-25: 2024-03-19 - Write Secondary Headers
Compiler
  * Write header for secondaries
  * Found REPL defect - freezes on input

TEN-24-24: 2024-03-18 - Write New Secondaries
* Introduce preprocessor: gcc -E -P file.s -o file.out   // -E = preprocessor only; -P = no line numbers generated
Compiler:
  * Write footer for secondaries (;)

TEN-24-23: 2024-03-14 - Meta Routines
* [offline] Extracted notes on ARM64, assembler, etc. to EnvironmentNotes.key
* [offline] Extracted notes on design to DesignNotes.key
* [offline] Updated README.md with notes on the Tenth language
Compiler
  * Develop a way to recognize meta words (search a list of names)
  * Make REPL call metas even in compile mode

TEN-24-22: 2024-03-13 - Read Multiple Lines
REPL
  * Repeat readLine if no words in line
  * Remove dead code for tokenize and eval
  * Rename eval1 to eval
Compiler
  * Allow you to enter/exit compile mode

TEN-24-21: 2024-03-12 - Tokenize in readWord
  * Skip spaces at front of word
  * Create assertStringEquals that prints mismatched strings
  * Allow multiple words/line
  * [Offline - moved assertStringEquals to asUnit.s]

TEN-24-20: 2024-03-11 - Multiple Words/Line
  * Move to x22 for the word pointer rather than x10
  * Refactor: Extract a function for unix read
  * Make readWord use x22, not start at inputBuffer always

TEN-24-19: 2024-03-07 - Detecting Incorrect Words
  * Make failed dictionary lookup report syntax error
  * Allow only one word per line [remove this restriction later]

TEN-24-18: 2024-03-06 - REPL
REPL
  * Write a REPL loop
  * We checked 1+1=2 and 2*3=6
  * Set up "real" system dictionary
  * Should runInterpreter take the data stack as given? [Helps REPL] Yes

TEN-24-17: 2024-03-05 - Eval
REPL
  * Eval for multi-word direct execution input
  * Tokenize: Replace spaces with \0 and append a \0
  * Read a string from the terminal

TEN-24-16: 2024-03-04 - Dictionary
Dictionary
  * Make dictionary search work
AsUnit
  * Write x0 and x1 in the assertion message
REPL
  * Eval for a one-word direct execution input

TEN-24-15: 2024-02-29 - Build System Dictionary
* Use ldp x0, x1, [SP, #16]! or stp x0, x1, [SP, #-16]! - to load two registers to consecutive stack locations - Didn't work, even with post-decrement
* Use CSET for relational expressions - applied to NEQ
* Make DICT_HEADER fill in slots for string entry and link - use pointer to arbitrary-length string
* Test dictionary init and DICT_HEADER
* Can now build dictionary of primary (primitive) functions
* Decision: X21 is global Dictionary Pointer AKA DP
* Started testing dict_search but only the trivial case works so far

TEN-24-14: 2024-02-28 - Refactor Dictionary Macros
* Simplify dictionary macros
* Rename _if_true to _jump_if_false
* Implement primitives: DUP, SUB, MUL, NEQ
* Check that secondaries handle recursion  - yay! inner interpreter is done

TEN-24-13: 2024-02-27 - Proper Secondary Headers
* Got secondaries calling secondaries to work
* Restore and fixed the 'if' tests

TEN-24-12: 2024-02-26 - Secondaries Calling Secondaries
* Lots of debugging, trying to straighten out the levels of indirection
* Working theory - secondary needs first word to store address of start2d, not its dictionary entry. Other words need to point to the dictionary entry.

TEN-24-11: 2024-02-14 - Recursion
* Attempted to have a secondary call a secondary. It's clear that the inner one didn't change x20 so it was not executing the inner steps.
* We tried changing how start2d finds the initial cell, trying to skip over the start2d reference itself, but that wasn't enough.
* It appears primaries and secondaries want different amounts of indirection; we tried adding another indirection cell for primaries, but it didn't work. (crashes)
* Could pick up debugging there next time.

TEN-24-10: 2024-02-13 - if_zero
* Support IF - via _if_true
* Support ELSE - via _if_true and _jump

TEN-24-09: 2024-02-12 - Printnum
* Renamed core.macros to assembler.macros; every .s file requires this first
* Print numeric - printnum() prints the number in x0
* Get one more level of indirection in interpreter

TEN-24-08: 2024-02-08 - Streq
* Use LOAD_ADDRESS in cLikeTests
* Implement streq
* Implement dec2str

TEN-24-07: 2024-02-07 - Interpreter Start
* Develop a do-nothing secondary to drive out the interpreter
* Develop a 1+2 secondary
* Develop the secondary interpreter

TEN-24-06: 2024-02-06 - To Add and Beyond
* Note: Stack pointer points to the next place to write
* Develop add primary
* Started building the interpreter (for secondaries & primaries)

TEN-24-05: 2024-02-05 - Stack Primaries
* Check print - uses x22 - is that a register callee can trash?
* Develop push

TEN-24-04: 2024-02-01 - Primaries and Secondaries
* Looked at a scheme for building primary and secondary code blocks
* Tried to build a primary - ran into a major barrier that you can't put relocatable addresses of code into data statements (Mac assembler limitation).
* Explored Mudshark666's idea of building a table of BL instructions, then digging the addresses out. Looks feasible. 
* We worked out how BL works: has 24 bits of room for a PC-relative address offset. The target address is right-shifted twice (as instruction addresses must be on 32-bit boundaries), then it's two high bytes are masked off. Bit 24 tells you whether it's a positive or negative offset.

TEN-24-03: 2024-01-31 - Print
* Use "make && ./unitTestDemo.out" to run more quickly 
* Extracted cLikeTests.s and asUnit.s, and adjusted makefile
* Make a c-like print function that takes an asciz string
* Improve test framework to print test name and pass or fail

TEN-24-02: 2024-01-30 - Unit Testing Framework
* Write a simple xUnit:
  + Write TEST_START and TEST_END macros
  + Moved test macros to asUnit.mnacros
* Used TDD to create a strlen function
* Moved strlen to cLike.s

TEN-24-01: 2024-01-29 - Introducing Tenth
* "Hello World" in assembler
* Figure out procedure calls (wasn't pushing LR)
* Figure out simple macros for exit and print
* Start creating a simple xUnit


xunit -
* test runner
* assertions
* reporting

create a procedure - a "normal" one
code
call assert
exit
