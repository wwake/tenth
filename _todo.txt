  * Read a string from the terminal
  * Read a string from a file
  * Set up "real" system dictionary
  * Develop a way to write secondaries to dictionary
  * Develop a way to recognize immediate words and enter/exit compile mode
  * Develop ": wordToDefine body ;"
  DUP 1 SUB
  : SUB1 DUP 1 SUB ;
REPL

* Update tests to use the DICT and SECONDARY macros
* Change data stack to a bigger size
* Should VSP point to the last element? instead of next free slot.
* Fix dec2str on most negative 64-bit number (-9223372036854775808) [?]
* Note that our arithmetic operations don't check for overflow
* Should runInterpreter take the data stack as given? [Helps REPL]

TEN-24-17: 2024-03-05 - Eval
REPL
  * Eval for multi-word direct execution input
  * Tokenize: Replace spaces with \0 and append a \0

TEN-24-16: 2024-03-04 - Dictionary
Dictionary
  * Make dictionary search work
AsUnit
  * Write x0 and x1 in the assertion message
REPL
  * Eval for a one-word direct execution input

TEN-24-15: 2024-02-29 - Build System Dictionary
* Use ldp x0, x1, [SP, #16]! or stp x0, x1, [SP, #-16]! - to load two registers to consecutive stack locations - Didn't work, even with post-decrement
* Use CSET for relational expressions - applied to NEQ
* Make DICT_HEADER fill in slots for string entry and link - use pointer to arbitrary-length string
* Test dictionary init and DICT_HEADER
* Can now build dictionary of primary (primitive) functions
* Decision: X21 is global Dictionary Pointer AKA DP
* Started testing dict_search but only the trivial case works so far

TEN-24-14: 2024-02-28 - Refactor Dictionary Macros
* Simplify dictionary macros
* Rename _if_true to _jump_if_false
* Implement primitives: DUP, SUB, MUL, NEQ
* Check that secondaries handle recursion  - yay! inner interpreter is done

TEN-24-13: 2024-02-27 - Proper Secondary Headers
* Got secondaries calling secondaries to work
* Restore and fixed the 'if' tests

TEN-24-12: 2024-02-26 - Secondaries Calling Secondaries
* Lots of debugging, trying to straighten out the levels of indirection
* Working theory - secondary needs first word to store address of start2d, not its dictionary entry. Other words need to point to the dictionary entry.

TEN-24-11: 2024-02-14 - Recursion
* Attempted to have a secondary call a secondary. It's clear that the inner one didn't change x20 so it was not executing the inner steps.
* We tried changing how start2d finds the initial cell, trying to skip over the start2d reference itself, but that wasn't enough.
* It appears primaries and secondaries want different amounts of indirection; we tried adding another indirection cell for primaries, but it didn't work. (crashes)
* Could pick up debugging there next time.

TEN-24-10: 2024-02-13 - if_zero
* Support IF - via _if_true
* Support ELSE - via _if_true and _jump

TEN-24-09: 2024-02-12 - Printnum
* Renamed core.macros to assembler.macros; every .s file requires this first
* Print numeric - printnum() prints the number in x0
* Get one more level of indirection in interpreter

TEN-24-08: 2024-02-08 - Streq
* Use LOAD_ADDRESS in cLikeTests
* Implement streq
* Implement dec2str

TEN-24-07: 2024-02-07 - Interpreter Start
* Develop a do-nothing secondary to drive out the interpreter
* Develop a 1+2 secondary
* Develop the secondary interpreter

TEN-24-06: 2024-02-06 - To Add and Beyond
* Note: Stack pointer points to the next place to write
* Develop add primary
* Started building the interpreter (for secondaries & primaries)

TEN-24-05: 2024-02-05 - Stack Primaries
* Check print - uses x10 - is that a register callee can trash?
* Develop push

TEN-24-04: 2024-02-01 - Primaries and Secondaries
* Looked at a scheme for building primary and secondary code blocks
* Tried to build a primary - ran into a major barrier that you can't put relocatable addresses of code into data statements (Mac assembler limitation).
* Explored Mudshark666's idea of building a table of BL instructions, then digging the addresses out. Looks feasible. 
* We worked out how BL works: has 24 bits of room for a PC-relative address offset. The target address is right-shifted twice (as instruction addresses must be on 32-bit boundaries), then it's two high bytes are masked off. Bit 24 tells you whether it's a positive or negative offset.

TEN-24-03: 2024-01-31 - Print
* Use "make && ./unitTestDemo.out" to run more quickly 
* Extracted cLikeTests.s and asUnit.s, and adjusted makefile
* Make a c-like print function that takes an asciz string
* Improve test framework to print test name and pass or fail

TEN-24-02: 2024-01-30 - Unit Testing Framework
* Write a simple xUnit:
  + Write TEST_START and TEST_END macros
  + Moved test macros to asUnit.mnacros
* Used TDD to create a strlen function
* Moved strlen to cLike.s

TEN-24-01: 2024-01-29 - Introducing Tenth
* "Hello World" in assembler
* Figure out procedure calls (wasn't pushing LR)
* Figure out simple macros for exit and print
* Start creating a simple xUnit


xunit -
* test runner
* assertions
* reporting

create a procedure - a "normal" one
code
call assert
exit
