
# Words that could be built in

# acb - move third item to second in stack
#   abc => acb
: acb cab swap ;

# bca - move top item to third in stack
#   abc => bca
: bca cab cab ;

# @++ - increment variable
#   variable-addr => ...   [but variable is incremented]
: @++
	dup	# var var
	@	# int var
	1 + # (int+1) var
	@=  # ...
;

# @-- - decrement variable
#   variable-addr => ...   [but variable is decremented]
: @--
	dup	# var var
	@	# int var
	1 - # (int+1) var
	@=  # ...
;

# dup2 - duplicate top two items of stack
#   abc => ababc
: dup2
	bab	# babc
	bab # ababc
;

: .$^ .$ pop ;

: ...
   "S= " .$^
   . " " .$^ bca
   . " " .$^ bca
   . " " .$^ bca
   nl
;

# string ... -> bool ...
: isEmpty$
	head$	# char string'
	swap pop # char
	==0		# bool
;


: head2$	# In: s2 s1 ...
	head$	# c2 s2' s1
	cab		# s1 c2 s2'
	head$ 	# c1 s1' c2 s2'
	cab	  	# c2 c1 s1' s2'
;

: ==$  # stack= s2 s1 ...
	head2$  # c2 c1 s1' s2'
	dup2	# c2 c1 c2 c1 s1' s2'
	bab		# c1 c2 c1 c2 c1 s1' s2'

	while	# c1 c2 c1 c2 c1 s1' s2'
		==	# bool c1 c2 c1 s1' s2'
		swap # c1 bool c2 c1 s1' s2'
		==0	# bool bool c2 c1 s1' s2'
		!	# bool bool c2 c1 s1' s2'
		&	# bool c2 c1 s1' s2'
	do
		# characters are == and not 0
		# c2 c1 s1' s2'

		pop pop		# s1' s2'
		head2$		# c1 c2 s1' s2'
		dup2		# c1 c2 c1 c2 s1' s2'
		bab			# c2 c1 c2 c1 c2 s1' s2'
	od

	# c2 c1 s1' s2'

	==			# bool s1' s2'

	cba			# s2' s1' bool
	pop pop		# bool
;

var s2a_index
var s2a_array

# string_to_array - convert string to array
# Effect:  string arrayPtr => ...
#
: string_to_array
	s2a_index 0 @=

	swap		# array string
	s2a_array swap @=	# string

	head$   # c string'

	while
		dup 	# c c string'
		0
		!=
	do			# c string'
		s2a_array @ swap	# c array string'
		s2a_index @		# index c array string'
		swap	# c index array string'
		@+=		# string'

		s2a_index @++
		head$	# c string'
	od

	# c(0) string'
	s2a_array @		# array 0 string'
	s2a_index @		# index array 0 string'
	cab		# 0 index array string'
	@+=		# string'
	pop
;

# length$ - get length of string
#   string => int
: length$
	0 swap	# string count(0)
	head$	# c string count

	while
		0 !=	# string count
	do
		swap 1 +	# count' string
		swap	# string count'
		head$	# c string' count'
	od

	# string count
	pop
;


var repeat_array
var repeat_char

# repeat$ - repeats characters to create a string
#   character array length
: repeat$
	repeat_char swap @=		# [store repeat character]
	repeat_array swap @=	# [store the array]
	0			# index length

	while
		dup2	# index length index length
		!=		# bool index length
	do			# index length
		dup		# index index length
		repeat_array @ swap	# index array index length
		repeat_char @ 		# '_' index array index length
		@+=		# index length
		1 + 	# index' length
	od

							# index length
	repeat_array @ swap 0	# 0 index array length
	@+=			# length
	pop
;

#####

# include tenthUnit
: assertEqual
	dup2

	==
	if
		pop pop
	else
		"Error: values differ" .$ pop nl
		"  a=" .$ pop
		. pop nl
		"  b=" .$ pop
		. pop nl
	fi
;

: assertEqual$
	dup2

	==$
	if
		pop pop
	else
		"Error: string values differ" .$ pop nl
		"  a=" .$ pop
		.$ pop nl
		"  b=" .$ pop
		.$ pop nl
	fi
;


#####
#  On to Hangman...

# Clear the screen (VT100 commands)
: screen_clear esc "[2J" .$^ ;

# screen_move_to - move the cursor to the specified position
#  in: col row ... => ...
: screen_move_to swap esc "[" .$^ . pop ";" .$^ . pop "H" .$^ ;

#####

2 array title	# array of strings

: title_init
	title 0 "HANGMAN" @+=
	title 1 "" @+=
;

title_init

#####

8 array scaffold  # array of strings

: scaffold_init
	scaffold 0 "_____" @+=
	scaffold 1 "|/   |" @+=
	scaffold 2 "|" @+=
	scaffold 3 "|" @+=
	scaffold 4 "|" @+=
	scaffold 5 "|" @+=
	scaffold 6 "|" @+=
	scaffold 7 "" @+=
;

scaffold_init



# draw_at - moves to row/col and draws the string
#	col row string ... => ...
: draw_at
	screen_move_to
	.$^
;


var draw_routine
var draw_index
var draw_column
var draw_row

# Draw array of strings, one per line, starting in given col and row
#    routine_name col row array ... => ...
: draw
	draw_routine swap @=		# col row array
	draw_index 0 @=
	draw_column swap @=			# row array
	draw_row swap @=			# array

	while				# array
		dup				# array array
		draw_index @	# int array array
		@+				# string array

		dup				# string string array
		isEmpty$		# bool string array
		!				# bool string array
	do					# string array
		draw_index @	# index string array
		draw_row @		# row index string array
		+				# (index+row) string array
		draw_column @	# col (index+row) string array

		draw_routine @	# routine_name col row string array
		call			# array

		draw_index @++	# array
	od

	# string array
	pop pop
;




# draw_body_common
#    string draw_routine col_offset row_offset col row ... => ...

var body_string
var body_draw_routine

: draw_body_common
	body_string swap @=			# col_offset row_offset col row
	body_draw_routine swap @=	# string col_offset row_offset col row

	cab							# col col_offset row_offset row
	+							# col+col_offset row_offset row
	bca							# row_offset row col+col_offset
	+							# row+row_offset col+col_offset
	swap						# col+col_offset row+row_offset
	body_string @				# string col' row'
	bca							# col' row' string

	body_draw_routine @ call	# [empty]
;

# draw_head
#   draw_routine col row ... =>  ...
: draw_head
	0 2		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"O"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_torso
#   draw_routine col row ... => ...
: draw_torso
	body_draw_routine swap @=	# col row
	dup2		# col row col row
	2 + 		# col+2 row col row
	swap 1 + swap # col+2 row+1 col row
	"|"			# string col row col row
	bca			# col row string col row
	body_draw_routine @ call	 # col row

	2 + 		# col+2 row
	swap 2 + swap # col+2 row+2
	"|"			# string col row
	bca			# col row string
	body_draw_routine @ call	 # col row
 ;

# draw_left_arm
#   draw_routine col row ... => ...
: draw_left_arm
	1 1		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"/"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_right_arm
#   draw_routine col row ... => ...
: draw_right_arm
	1 3		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"\"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_left_hand
#   draw_routine col row ... => ...
: draw_left_hand
	1 0		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"_"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_right_hand
#   draw_routine col row ... => ...
: draw_right_hand
	1 4		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"_"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_left_leg
#   draw_routine col row ... => ...
: draw_left_leg
	3 1		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"/"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_right_leg
#   draw_routine col row ... => ...
: draw_right_leg
	3 3		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"\"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_left_foot
#   draw_routine col row ... => ...
: draw_left_foot
	3 0		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"_"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_right_foot
#   draw_routine col row ... => ...
: draw_right_foot
	3 4		# col_offset row_offset draw_routine col row
	cab		# draw_routine col_offset row_offset col row
	"_"		# string draw_routine col_offset row_offset col row
	draw_body_common	# empty
;

# draw_partial_body - calls routines in the array, up to but not including the given count
#   In: array count draw_routine col row
var drawing_array
var draw_count
var draw_routine

: draw_partial_body
	drawing_array swap @=	# count draw_routine col row
	draw_count swap @=		# draw_routine col row
	draw_routine swap @=	# col row

	while		# col row
		draw_count @
		0
		!=		# bool col row
	do			# col row
		draw_count @--
		dup2	# col row col row
		draw_routine @	# draw-routine col row col row
		drawing_array @ draw_count @ @+	# part-routine draw_routine col row col row
		call	# col row
	od
			# col row
	pop pop # [empty]
;


12 array draw_body_array

: draw_body_init
	draw_body_array 0 "draw_head" @+=
	draw_body_array 1 "draw_torso" @+=
	draw_body_array 2 "draw_left_arm" @+=
	draw_body_array 3 "draw_right_arm" @+=
	draw_body_array 4 "draw_left_hand" @+=
	draw_body_array 5 "draw_right_hand" @+=
	draw_body_array 6 "draw_left_leg" @+=
	draw_body_array 7 "draw_right_leg" @+=
	draw_body_array 8 "draw_left_foot" @+=
	draw_body_array 9 "draw_right_foot" @+=
;

#######

# Game State

100 array clue

100 array answer

30 array wrong_guesses
var wrong_guesses_index


# Initialization
: wrong_guesses_init
	29 wrong_guesses 0 repeat$
	wrong_guesses_index 0 @=
;

# game_init - saves answer string and creates initial clue
#  Note: 95=_
# Input: answer - top of stack
# Output: sets answerString
#
: game_init			# string
	wrong_guesses_init
	draw_body_init

	dup				# string string
	answer swap		# string answer string

	string_to_array	# string [and builds the answer array]

	length$		# length
	clue 		# array length
	95			# '_' array length
	repeat$
;

# you_win - true iff your guesses match the answer
#   ... => bool ...
: you_win
	clue make$
	answer make$
	==$
;

# you_lose - true iff you run out of guesses
: you_lose
	wrong_guesses make$	# string
	length$				# length
	10					# limit length
	>=					# bool
;

# game_over - is game over? ie answer is guessed
#	In: none => bool
#
: game_over
	you_win
	you_lose
	|
;

# game_state - string showing win, lost, or neither
#   ... => string ...
: game_state
	game_over
	if
		you_win
		if
			"GAME OVER - YOU WIN!!"
		else
			"GAME OVER - YOU LOSE:("
		fi
	else
		""
	fi
;

# game_display - show game state
: game_display
	screen_clear

	title 2 35 "draw_at" draw

	clue make$ 4 35 draw_at

	scaffold 6 35 "draw_at" draw

	8 38 "draw_at" wrong_guesses make$ length$ draw_body_array draw_partial_body

	"Wrong guesses: " 15 20 draw_at

	wrong_guesses make$ 15 35 draw_at

	game_state 9 47 draw_at

	"" 24 1 draw_at
;


# update_clue - adjust clue if character is found. Return true if character found.
#   ch ... => bool ...

var clue_index

: update_clue
	clue_index 0 @=		# ch
	0 swap				# ch result(0)

	while
		answer clue_index @ @+	# ch-ans ch result
		dup		# ch-ans ch-ans ch result
		0		# 0 ch-ans ch-ans ch result
		!=		# bool ch-ans ch result
	do			# ch-ans ch result
		bab		# ch ch-ans ch result
		==			# bool ch result
		if			# ch result
			dup		# ch ch result
			clue clue_index @ cab @+=  	# ch result
			swap pop 1 swap		# ch result(true)
		fi			# ch result
		clue_index @++
	od

			# ch-ans ch result
	pop pop	# result
;

# update_wrong_guess - stores character in list of wrong guesses
#   ch => ...
: update_wrong_guess
	wrong_guesses wrong_guesses_index @	# index wrong_guesses ch
	cab		# ch index wrong_guesses
	@+=		#

	wrong_guesses_index @++
;



# update_wrong_body
#   draw_routine col row
: update_wrong_body
	wrong_guesses make$ length$
	pop		# really should look up the right drawing routine

	"draw_head"	call	# draw_routine
;

# game_loop - given answer, run the game until game is over
#   readRoutine displayRoutine => ...
: game_loop
	bab call	# read display

	while		# read display
		game_over	# bool read display
		!			# bool read display
	do			# read display
		dup		# read read display
		call	# ch read display
		dup		# ch ch read display
		update_clue	# bool ch read display
		!			# bool ch read display
		if			# ch read display
			update_wrong_guess # read display
		else		# ch read display
			pop		# read display
		fi

		bab		# display read display
		call	# read display
	od

	# read display
	pop pop
;

# hangman - run the game
#   Input: top of stack = answer
#   Result: empty stack
: hangman
	game_init
	"game_display" "getc" game_loop
;
