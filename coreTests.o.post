
.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm

.include "unix_functions.macros"
.include "asUnit.macros"
.include "coreTests.macros"
.include "repl.macros"
.global _start
.p2align 2
_start:
 str lr, [sp, #-16]!
 TEST_ALL "coreTests"
 // Definition
 bl colon_switches_to_compile_mode
 bl colon_writes_header_to_secondary
 bl semicolon_switches_to_run_mode
 bl semicolon_writes_end2d_in_secondary
 // Stack
 bl push_pushes_one_item
 bl dup_duplicates_top_item
 // Arithmetic
 bl add_b_plus_a_is_a
 bl sub_b_minus_a_is_difference
 bl mul_b_by_a_is_product
 // Logical
 bl neq_true_if_values_differ
 bl neq_false_if_values_the_same
 // Conditional
 bl if_zero_does_not_jump_for_non_zero_value
 bl if_zero_jumps_for_zero_value
 bl jump_skips_over_code
 unix_exit
 ldr lr, [sp], #16
 ret
TEST_START colon_switches_to_compile_mode
 LOAD_ADDRESS x25, L_test_secondary_area
 LOAD_ADDRESS x26, L_readWords
 mov x24, RUN_MODE
 bl _colon
 mov x0, x24
 mov x1, COMPILE_MODE
 bl assertEqual
TEST_END
.data
.p2align 3
L_test_secondary_area:
 .fill 16, 8, 0
.p2align 3
L_colon_test_string:
 .asciz "xy34567 "
L_colon_test_string_final:
 .asciz "xy34567"
.text
.align 2
// L_readWords - read words for test
// Input: x0=#0, x1=addr of buffer, x2=#chars max to read
//
L_readWords:
 str lr, [sp, #-16]!
 // Copy test string to real inputBuffer
 LOAD_ADDRESS x0, L_colon_test_string
 LOAD_ADDRESS x1, inputBuffer
 bl strcpyz
 ldr lr, [sp], #16
 ret
TEST_START colon_writes_header_to_secondary
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 LOAD_ADDRESS x26, L_readWords
 mov x21, #800
 // Act:
 bl _colon
 // Assert:
 LOAD_ADDRESS x0, L_test_secondary_area
 LOAD_ADDRESS x1, L_colon_test_string_final
 bl assertEqualStrings
 mov x0, x25
 LOAD_ADDRESS x1, L_test_secondary_area
 add x1, x1, #8
 bl assertEqual
 // LTSA + 8 should be same as old dictionary pointer
 // LTSA + 16 should point to LTSA
 // LTSA + 24 should point to start2d
 // Dictionary pointer should be updated
//	bl assertEqual
TEST_END
TEST_START semicolon_switches_to_run_mode
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 mov x24, COMPILE_MODE
 // Act:
 bl _semicolon
 // Assert:
 mov x0, x24
 mov x1, RUN_MODE
 bl assertEqual
TEST_END
.text
.align 2
TEST_START semicolon_writes_end2d_in_secondary
 // Arrange:
 LOAD_ADDRESS x25, L_test_secondary_area
 // Act:
 bl _semicolon
 // Assert:
 // Check that cell gets end2d's word address
 LOAD_ADDRESS x0, L_test_secondary_area
 ldr x0, [x0]
 ldr x0, [x0]
 LOAD_ADDRESS x1, end2d_wordAddress
 ldr x1, [x1]
 bl assertEqual
 // Check that SEC_SPACE moved forward after writing
 mov x0, x25
 LOAD_ADDRESS x1, L_test_secondary_area
 add x1, x1, #8
 bl assertEqual
TEST_END
.data
.p2align 2
L_push_test_stack: .quad 0, 99, 0, 0
.text
L_data: .quad 142, 58
TEST_START push_pushes_one_item
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 mov x0, x20
 adr x1, L_data
 add x1, x1, #8 // expect VPC to increment
 bl assertEqual
 mov x0, x19
 LOAD_ADDRESS x1, L_push_test_stack
 add x1, x1, #8 // Expect original stack+8
 bl assertEqual
 LOAD_ADDRESS x0, L_push_test_stack
 ldr x0, [x0]
 mov x1, #142 // Expected stack contents
 bl assertEqual
TEST_END
TEST_START dup_duplicates_top_item
 // Arrange:
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 // Act:
 bl dup
 // Assert:
 DATA_POP_AB x0, x1
 mov x28, x0
 bl assertEqual
 mov x0, x28
 mov x1, #142
 bl assertEqual
TEST_END
.data
L_VSP_Update: .asciz "VSP should be incremented"
L_stack_update: .asciz "Stack should have data"
L_VPC_Update: .asciz "VPC should be incremented"
.p2align 2
.text
.p2align 2
TEST_START add_b_plus_a_is_a
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 bl _push
 bl add
 mov x0, x19
 LOAD_ADDRESS x1, L_push_test_stack
 add x1, x1, #8 // Expect original stack+8
 bl assertEqual
 LOAD_ADDRESS x0, L_push_test_stack
 ldr x0, [x0]
 mov x1, #200 // Expected stack contents
 bl assertEqual
TEST_END
TEST_START sub_b_minus_a_is_difference
 // Arrange:
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 adr x20, L_data + 8
 bl _push
 // Act:
 bl sub
 // Assert:
 DATA_POP x0
 mov x1, #84
 bl assertEqual
TEST_END
TEST_START mul_b_by_a_is_product
 // Arrange:
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 adr x20, L_data + 8
 bl _push
 // Act:
 bl mul
 // Assert:
 DATA_POP x0
 mov x1, #8236
 bl assertEqual
TEST_END
TEST_START neq_true_if_values_differ
 // Arrange:
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 adr x20, L_data + 8
 bl _push
 // Act:
 bl neq
 // Assert:
 DATA_POP x0
 mov x1, #1
 bl assertEqual
TEST_END
TEST_START neq_false_if_values_the_same
 // Arrange:
 LOAD_ADDRESS x19, L_push_test_stack
 adr x20, L_data
 bl _push
 adr x20, L_data
 bl _push
 // Act:
 bl neq
 // Assert:
 DATA_POP x0
 mov x1, #0
 bl assertEqual
TEST_END
.data
.p2align 8
debugData:
L_test_dictionary:
 .quad 1
 .quad 2
 .quad 3
 .quad 5
 .quad 7
 .quad 11
 .quad 13
 .quad 17
L_test_secondary:
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
 .quad 0
.text
TEST_START if_zero_does_not_jump_for_non_zero_value
// Arrange
 DICT_START L_test_dictionary
 DICT_ADD _jump_if_false // 0
 DICT_ADD _push // 1
 DICT_ADD end2d // 2
 SECONDARY_START L_test_secondary, L_test_dictionary, start2d
 SECONDARY_ADD 1
 SECONDARY_DATA #7
 SECONDARY_ADD 0
 SECONDARY_TARGET 7
 SECONDARY_ADD 1
 SECONDARY_DATA #42
 SECONDARY_ADD 2
// Act
 LOAD_ADDRESS x0, L_test_secondary
 bl runInterpreter
// Assert
 DATA_TOP x0
 mov x1, #42
 bl assertEqual
TEST_END
TEST_START if_zero_jumps_for_zero_value
 // Arrange
 DICT_START L_test_dictionary
 DICT_ADD _jump_if_false
 DICT_ADD _push
 DICT_ADD end2d
 SECONDARY_START L_test_secondary, L_test_dictionary, start2d
 SECONDARY_ADD 1
 SECONDARY_DATA #0
 SECONDARY_ADD 0
 SECONDARY_TARGET 7
 SECONDARY_ADD 1
 SECONDARY_DATA #42
 SECONDARY_ADD 2
// Act
 LOAD_ADDRESS x0, L_test_secondary
 bl runInterpreter
// Assert
 mov x0, x19
 LOAD_ADDRESS x1, data_stack
 bl assertEqual // check that VSP is back to original place
TEST_END
TEST_START jump_skips_over_code
// Arrange
 DICT_START L_test_dictionary
 DICT_ADD _jump //0
 DICT_ADD _push //1
 DICT_ADD end2d //2
 SECONDARY_START L_test_secondary, L_test_dictionary, start2d
 SECONDARY_ADD 0
 SECONDARY_TARGET 5
 SECONDARY_ADD 1
 SECONDARY_DATA #17
 SECONDARY_ADD 2
 // Act
 LOAD_ADDRESS x0, L_test_secondary
 bl runInterpreter
// Assert
 mov x0, x19
 LOAD_ADDRESS x1, data_stack
 bl assertEqual // check that VSP is back to original place
TEST_END
