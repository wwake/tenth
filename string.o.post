// Global register values
// Free: x23, x28

.macro LOAD_ADDRESS register, location
 adrp \register, \location@PAGE
 add \register, \register, \location@PAGEOFF
.endm
.macro DATA_PUSH register
 str \register, [x19], #8
.endm
.macro DATA_PUSH_AB register1, register2
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_PUSH_ABC register1, register2, register3
 DATA_PUSH \register3
 DATA_PUSH \register2
 DATA_PUSH \register1
.endm
.macro DATA_POP register
 ldr \register, [x19, #-8]!
.endm
.macro DATA_POP_AB register1, register2
 DATA_POP \register1
 DATA_POP \register2
.endm
.macro DATA_POP_ABC register1, register2, register3
 DATA_POP_AB \register1, \register2
 DATA_POP \register3
.endm
.macro DATA_TOP register
 ldr \register, [x19, #-8]
.endm
.macro CONTROL_PUSH register
 str \register, [x27], #8
.endm
.macro CONTROL_POP register
 ldr \register, [x27, #-8]!
.endm
.macro STD_PROLOG
 str lr, [sp, #-16]!
.endm
.macro STD_EPILOG
 ldr lr, [sp], #16
.endm
// Store register contents into next slot in secondary
.macro STORE_SEC register
 str \register, [x25], #8
.endm
.macro ROUND_UP_8 register
 add \register, \register, #8
 and \register, \register, #-8
.endm

.global make_string
.global head_string
.text
.align 2
// make_string: convert array to string
// Input:
//   a - top of stack has address of array
// Output:
//   a - top of stack replaced with address of string
//
make_string:
 DATA_POP x0
 DATA_PUSH x25
L_make_loop:
 ldr x1, [x0], #8
 cmp x1, #0
 b.eq L_make_exiting
  strb w1, [x25], #1
 b L_make_loop
L_make_exiting:
 strb wzr, [x25], #1
 ROUND_UP_8 x25
 ret
// head_string - pop address of string, push address of string with first character removed, and push that character (as an integer)
//
head_string:
 DATA_POP x0
 ldrb w1, [x0], #1
 cmp w1, #0
 b.ne L_end_head_string
  sub x0, x0, #1
L_end_head_string:
 DATA_PUSH x0
 DATA_PUSH x1
 ret
